/**
 * Функция `drawGraph` генерирует график на основе данного выражения в обратной польской нотации и
 * его длины.
 * 
 * @param rpn Функция `drawGraph`, которую вы предоставили, по-видимому, рисует график на основе
 * выражения в обратной польской нотации (ОПН). Параметр `rpn` — это двумерный массив символов, представляющий 
 * выражение ОПН. Параметр `rpnLength` указывает длину выражения ОПН.
 * @param rpnLength Параметр `rpnLength` в функции `drawGraph` представляет длину
 * выражения в обратной польской нотации (ОПН), хранящегося в двумерном массиве `rpn`. Он указывает 
 * количество элементов в выражении ОПН, которые нужно оценить для отрисовки графика.
 */
#include "Headers/graph.h"

void drawGraph(char rpn[MAX_EXPR_SIZE][MAX_EXPR_SIZE], int rpnLength) { // Объявление функции drawGraph, принимающей массив OПН и его длину
    char graph[HEIGHT][WIDTH]; // Объявление двумерного массива для хранения графика, размер задается константами HEIGHT и WIDTH
    for (int i = 0; i < HEIGHT; i++) { // Внешний цикл для инициализации каждой строки графика
        for (int j = 0; j < WIDTH; j++) { // Внутренний цикл для инициализации каждого столбца графика
            graph[i][j] = '.'; // Заполнение графика символом '.' (точка), указывающим на пустую область
        }
    }

    double x_scale = (double)(WIDTH - 1) / (4 * M_PI - 0); // Вычисление шкалы по оси X для масштабирования графика
    double y_scale = (double)(HEIGHT - 1) / (1 - (-1)); // Вычисление шкалы по оси Y для масштабирования графика

    for (int i = 0; i < WIDTH; i++) { // Цикл по ширине графика
        double x = i * (4 * M_PI) / (WIDTH - 1); // Вычисление текущего значения x, пропорционально ширине графика
        double y = evaluateRPN(rpn, rpnLength, x); // Вычисление значения y по выражению в ОПН для текущего значения x

        int graph_x = (int)(x * x_scale); // Преобразование значения x в координату графика, с учетом масштаба
        int graph_y = (int)(((y + 1) * y_scale)); // Преобразование значения y в координату графика, с учетом масштаба и сдвига на 1

        if (graph_x >= 0 && graph_x < WIDTH && graph_y >= 0 && graph_y < HEIGHT) { // Проверка, находится ли точка в пределах графика
            graph[HEIGHT - 1 - graph_y][graph_x] = '*'; // Помещение символа '*' на график в вычисленную позицию
        }
    }

    for (int i = 0; i < HEIGHT; i++) { // Цикл по высоте графика для вывода на экран
        for (int j = 0; j < WIDTH; j++) { // Цикл по ширине графика для вывода каждой строки
            putchar(graph[i][j]); // Вывод текущего символа графика
        }
        putchar('\n'); // Переход на новую строку после завершения вывода одной строки графика
    }
}