/**
 * В приведенном коде определены функции для преобразования инфиксных выражений в Обратную Польскую нотацию (ОПН) с использованием
 * алгоритма Дейкстры.
 * 
 * @param op Параметр `op` в функции `precedence` представляет собой арифметический оператор, для
 * которого мы хотим определить приоритет (приоритет/порядок выполнения). Это массив символов
 * (строка), содержащий символ оператора, такой как "+", "-", "*", или "/".
 * 
 * @return В предоставленном коде нет оператора возврата внутри функции `infixToRPN`. Эта
 * функция отвечает за преобразование инфиксного выражения в Обратную Польскую нотацию (ОПН) с использованием
 * алгоритма Дейкстры. Результат преобразования хранится в массиве `rpn`, а длина
 * полученного выражения ОПН хранится в переменной `rpnLength`.
 */

#include "Headers/translate.h" // Подключение заголовочного файла, содержащего функции для перевода выражений в польскую запись

/**
 * Функция вычисляет приоритет (порядок выполнения) арифметических операций на основе
 * предоставленного оператора.
 * 
 * @param op Параметр `op` в функции `precedence` является указателем на массив символов (строку),
 * представляющим арифметическую операцию, такую как сложение "+", вычитание "-", умножение "*" или
 * деление "/". Функция сравнивает эту операцию с предопределенными арифметическими операторами и возвращает
 * значение приоритета в зависимости от типа операции.
 * 
 * @return Приоритет (порядок выполнения) арифметической операции на основе входного оператора.
 * Если оператор является сложением или вычитанием, он возвращает 1, что указывает на низкий приоритет.
 * Если оператор является умножением или делением, он возвращает 2, что указывает на высокий приоритет.
 * Если оператор не распознан, он возвращает 0.
 */
// Рассчет порядка выполнения арифметических операций
int precedence(char* op) { // Функция для определения приоритета (порядка выполнения) арифметической операции
    if (strcmp(op, "+") == 0 || strcmp(op, "-") == 0) return 1; // Сложение и вычитание имеют низкий приоритет (1)
    if (strcmp(op, "*") == 0 || strcmp(op, "/") == 0) return 2; // Умножение и деление имеют высокий приоритет (2)
    return 0; // Если операция не распознана, возвращаем 0
}

// Разбиение строки на токены для перевода в польскую запись
/**
 * Функция `tokenize` разбивает инфиксное выражение на токены, основываясь на цифрах, буквах и
 * операторах.
 * 
 * @param infix Параметр `infix` в функции `tokenize` представляет входное инфиксное выражение,
 * которое необходимо токенизировать. Это массив символов (`const char*`), содержащий инфиксное выражение,
 * которое будет обработано и разбито на токены.
 * @param tokens `tokens` - это двумерный массив символов, в котором будут храниться токены,
 * извлеченные из инфиксного выражения `infix`. Каждая строка в `tokens` представляет токен,
 * а каждый столбец представляет символ в этом токене.
 * @param tokenCount Параметр `tokenCount` в функции `tokenize` является указателем на целое число.
 * Этот параметр используется для хранения общего количества токенов, найденных в входном инфиксном выражении
 * `infix` после токенизации. Функция обновляет значение, на которое указывает `tokenCount`, по мере обработки токенов.
 */
void tokenize(const char* infix, char tokens[MAX_EXPR_SIZE][MAX_EXPR_SIZE], int* tokenCount) { // Функция для разбиения инфиксного выражения на токены
    int i = 0; // Индекс текущего символа в строке
    *tokenCount = 0; // Инициализация счетчика токенов

    while (infix[i] != '\0') { // Цикл продолжается, пока не достигнут конец строки
        if (isdigit(infix[i]) || (infix[i] == '.' && isdigit(infix[i + 1]))) { // Проверка на число, включая десятичные точки
            int j = 0; // Индекс для заполнения токена
            while (isdigit(infix[i]) || infix[i] == '.') { // Чтение токена, пока встречаются цифры или точка
                tokens[*tokenCount][j++] = infix[i++]; // Добавление символа к текущему токену
            }
            tokens[*tokenCount][j] = '\0'; // Завершение строки токена
            (*tokenCount)++; // Увеличение счетчика токенов
        } else if (isalpha(infix[i])) { // Проверка на переменную (букву)
            int j = 0; // Индекс для заполнения токена
            while (isalpha(infix[i])) { // Чтение токена, пока идет буква
                tokens[*tokenCount][j++] = infix[i++]; // Добавление символа к текущему токену
            }
            tokens[*tokenCount][j] = '\0'; // Завершение строки токена
            (*tokenCount)++; // Увеличение счетчика токенов
        } else if (strchr("+-*/()", infix[i])) { // Проверка на оператор или скобку
            tokens[*tokenCount][0] = infix[i++]; // Заполнение токена текущим символом
            tokens[*tokenCount][1] = '\0'; // Завершение строки токена
            (*tokenCount)++; // Увеличение счетчика токенов
        } else {
            i++;  // Пропускаем неправильные значения
            // TODO: Сделать проверку ввода? // Доработать проверку на некорректный ввод
        }
    }
}

/**
 * Функция `infixToRPN` преобразует инфиксное выражение в Обратную Польскую Нотацию, используя алгоритм Дейкстры.
 * 
 * @param infix Параметр `infix` в функции `infixToRPN` представляет собой математическое выражение
 * в инфиксной нотации, которое вы хотите преобразовать в Обратную Польскую Нотацию (ОПН). В инфиксной
 * нотации операторы записываются между своими операндами, например, `2 + 3 * 4`.
 * @param rpn Параметр `rpn` в функции `infixToRPN` является двумерным массивом символов. Он используется
 * для хранения результирующего выражения в Обратной Польской Нотации (ОПН) после преобразования
 * данного инфиксного выражения. Функция заполняет этот массив токенами.
 * @param rpnLength Параметр `rpnLength` в функции `infixToRPN` является указателем на целое число,
 * который используется для отслеживания длины результирующего массива выражения
 * Обратной Польской Нотации (ОПН) `rpn`. Он увеличивается по мере обработки и добавления токенов в массив.
 */
// Конвертация в польскую нотацию алгоритмом Дijkstra
void infixToRPN(char* infix, char rpn[MAX_EXPR_SIZE][MAX_EXPR_SIZE], int* rpnLength) { // Функция для преобразования инфиксного выражения в постфиксное (польская запись)
    StringStack stack; // Объявление стека для операторов
    stack.top = -1; // Инициализация верхушки стека
    char tokens[MAX_EXPR_SIZE][MAX_EXPR_SIZE]; // Массив токенов для хранения разбитого выражения
    int tokenCount; // Счетчик токенов

    // Разбиваем строку на подстроки с ключевыми значениями
    tokenize(infix, tokens, &tokenCount); // Вызов функции tokenize для разбивки ввода на токены

    *rpnLength = 0; // Инициализация длины результирующего массива

    for (int i = 0; i < tokenCount; i++) { // Итерация по всем токенам
        if (isdigit(tokens[i][0]) || tokens[i][0] == 'x') {  // Обработка чисел и переменной x
            strcpy(rpn[(*rpnLength)++], tokens[i]); // Копирование токена в выходной массив RPN
        } else if (isfunction(tokens[i])) {  // Обработка функций
            pushString(&stack, tokens[i]); // Добавление функции на стек
        } else if (strcmp(tokens[i], "(") == 0) {  // Обработка левых скобок
            pushString(&stack, tokens[i]); // Добавление левой скобки на стек
        } else if (strcmp(tokens[i], ")") == 0) {  // Обработка правых скобок
            while (stack.top != -1 && strcmp(stack.items[stack.top], "(") != 0) { // Извлечение из стека, пока не найдена левая скобка
                strcpy(rpn[(*rpnLength)++], popString(&stack)); // Копирование на выходной массив
            }
            popString(&stack);  // Удаляем из стека левые скобки
            if (stack.top != -1 && isfunction(stack.items[stack.top])) { // Если на стеке осталась функция
                strcpy(rpn[(*rpnLength)++], popString(&stack)); // Извлечение функции из стека
            }
        } else if (isoperator(tokens[i])) {  // Обработка арифметических операций
            while (stack.top != -1 && precedence(stack.items[stack.top]) >= precedence(tokens[i])) { // Сравнение приоритетов операций
                strcpy(rpn[(*rpnLength)++], popString(&stack)); // Копирование оператора на выходной массив
            }
            pushString(&stack, tokens[i]); // Добавление текущего оператора на стек
        }
    }

    // Удаляем все оставшиеся неиспользованные операторы
    while (stack.top != -1) { // Пока стек не пуст
        strcpy(rpn[(*rpnLength)++], popString(&stack)); // Перемещение оставшихся операторов в выходной массив
    }
}